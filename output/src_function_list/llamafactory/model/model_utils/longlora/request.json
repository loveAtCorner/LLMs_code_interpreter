{
    "model": "qwen1.5-32b-chat-int4",
    "messages": [
        {
            "role": "system",
            "content": "你是python源码结构和逻辑的解析专家，非常擅长剖析核心代码的功能"
        },
        {
            "role": "user",
            "content": "返回下面这个脚本当中所有函数或者类的名称，及其对应的功能\n返回内容的格式需要遵循markdown表格的形式\n\n```python\nimport math\nfrom typing import TYPE_CHECKING, Optional, Tuple\n\nimport torch\nimport torch.nn as nn\nfrom transformers.models.llama.modeling_llama import (\n    Cache,\n    LlamaAttention,\n    LlamaFlashAttention2,\n    LlamaSdpaAttention,\n    apply_rotary_pos_emb,\n    repeat_kv,\n)\nfrom transformers.utils import logging\nfrom transformers.utils.versions import require_version\n\nfrom ...extras.constants import SUPPORTED_CLASS_FOR_S2ATTN\nfrom ...extras.logging import get_logger\n\n\nif TYPE_CHECKING:\n    from transformers import PretrainedConfig\n\n    from ...hparams import ModelArguments\n\n\ntransformers_logger = logging.get_logger(__name__)\n\n\n\n\ndef llama_attention_forward(\n    self: \"LlamaAttention\",\n    hidden_states: torch.Tensor,\n    attention_mask: Optional[torch.Tensor] = None,\n    position_ids: Optional[torch.LongTensor] = None,\n    past_key_value: Optional[\"Cache\"] = None,\n    output_attentions: bool = False,\n    cache_position: Optional[torch.LongTensor] = None,\n    **kwargs,\n) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n    bsz, q_len, _ = hidden_states.size()\n\n    query_states: \"torch.Tensor\" = self.q_proj(hidden_states)\n    key_states: \"torch.Tensor\" = self.k_proj(hidden_states)\n    value_states: \"torch.Tensor\" = self.v_proj(hidden_states)\n\n    query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n    key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n    value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n    cos, sin = self.rotary_emb(value_states, position_ids)\n    query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n    past_key_value = getattr(self, \"past_key_value\", past_key_value)\n\n    if past_key_value is not None:\n        cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n        key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n    key_states = repeat_kv(key_states, self.num_key_value_groups)\n    value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n    if getattr(self.config, \"group_size_ratio\", None) and self.training:  \n        groupsz = int(q_len * getattr(self.config, \"group_size_ratio\"))\n        assert q_len % groupsz == 0, \"q_len {} should be divisible by group size {}.\".format(q_len, groupsz)\n        num_groups = q_len // groupsz\n\n        def shift(state: \"torch.Tensor\") -> \"torch.Tensor\":\n            state = state.transpose(1, 2)  \n            state = torch.cat(\n                (state[:, :, : self.num_heads // 2], state[:, :, self.num_heads // 2 :].roll(-groupsz // 2, dims=1)),\n                dim=2,\n            )\n            return state.reshape(bsz * num_groups, groupsz, self.num_heads, self.head_dim).transpose(1, 2)\n\n        query_states, key_states, value_states = shift(query_states), shift(key_states), shift(value_states)\n        if attention_mask is not None:\n            attention_mask = attention_mask[:, :, :groupsz, :groupsz].repeat(num_groups, 1, 1, 1)\n\n    attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) / math.sqrt(self.head_dim)\n\n    if attention_mask is not None:  \n        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n        attn_weights = attn_weights + causal_mask\n\n    \n    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n    attn_weights = nn.functional.dropout(attn_weights, p=self.attention_dropout, training=self.training)\n    attn_output = torch.matmul(attn_weights, value_states)  \n    attn_output = attn_output.transpose(1, 2).contiguous()\n\n    if getattr(self.config, \"group_size_ratio\", None) and self.training:  \n        attn_output.reshape(bsz, q_len, self.num_heads, self.head_dim)\n        attn_output = torch.cat(\n            (\n                attn_output[:, :, : self.num_heads // 2],\n                attn_output[:, :, self.num_heads // 2 :].roll(groupsz // 2, dims=1),\n            ),\n            dim=2,\n        )\n\n    attn_output = attn_output.reshape(bsz, q_len, self.hidden_size)\n    attn_output = self.o_proj(attn_output)\n\n    if not output_attentions:\n        attn_weights = None\n\n    return attn_output, attn_weights, past_key_value\n\n\n\n\ndef llama_flash_attention_2_forward(\n    self: \"LlamaFlashAttention2\",\n    hidden_states: torch.Tensor,\n    attention_mask: Optional[torch.Tensor] = None,\n    position_ids: Optional[torch.LongTensor] = None,\n    past_key_value: Optional[\"Cache\"] = None,\n    output_attentions: bool = False,\n    cache_position: Optional[torch.LongTensor] = None,\n    **kwargs,\n) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n    \n    output_attentions = False\n\n    bsz, q_len, _ = hidden_states.size()\n\n    query_states: \"torch.Tensor\" = self.q_proj(hidden_states)\n    key_states: \"torch.Tensor\" = self.k_proj(hidden_states)\n    value_states: \"torch.Tensor\" = self.v_proj(hidden_states)\n\n    query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n    key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n    value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n    cos, sin = self.rotary_emb(value_states, position_ids)\n    query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n    past_key_value = getattr(self, \"past_key_value\", past_key_value)\n\n    if past_key_value is not None:\n        cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n        key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n    key_states = repeat_kv(key_states, self.num_key_value_groups)\n    value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n    \n    query_states = query_states.transpose(1, 2)\n    key_states = key_states.transpose(1, 2)\n    value_states = value_states.transpose(1, 2)\n\n    dropout_rate = self.attention_dropout if self.training else 0.0\n\n    input_dtype = query_states.dtype\n    if input_dtype == torch.float32:\n        if torch.is_autocast_enabled():\n            target_dtype = torch.get_autocast_gpu_dtype()\n        elif hasattr(self.config, \"_pre_quantization_dtype\"):\n            target_dtype = self.config._pre_quantization_dtype\n        else:\n            target_dtype = self.q_proj.weight.dtype\n\n        transformers_logger.warning_once(\"The input hidden states seems to be silently casted in float32.\")\n        query_states = query_states.to(target_dtype)\n        key_states = key_states.to(target_dtype)\n        value_states = value_states.to(target_dtype)\n\n    if getattr(self.config, \"group_size_ratio\", None) and self.training:  \n        groupsz = int(q_len * getattr(self.config, \"group_size_ratio\"))\n        assert q_len % groupsz == 0, \"q_len {} should be divisible by group size {}.\".format(q_len, groupsz)\n        num_groups = q_len // groupsz\n\n        def shift(state: \"torch.Tensor\") -> \"torch.Tensor\":\n            state = torch.cat(\n                (state[:, :, : self.num_heads // 2], state[:, :, self.num_heads // 2 :].roll(-groupsz // 2, dims=1)),\n                dim=2,\n            )\n            return state.reshape(bsz * num_groups, groupsz, self.num_heads, self.head_dim)\n\n        query_states, key_states, value_states = shift(query_states), shift(key_states), shift(value_states)\n        if attention_mask is not None:\n            attention_mask = attention_mask[:, :groupsz].repeat(num_groups, 1)\n\n    attn_output: \"torch.Tensor\" = self._flash_attention_forward(\n        query_states, key_states, value_states, attention_mask, query_states.size(1), dropout=dropout_rate\n    )\n\n    if getattr(self.config, \"group_size_ratio\", None) and self.training:  \n        attn_output.reshape(bsz, q_len, self.num_heads, self.head_dim)\n        attn_output = torch.cat(\n            (\n                attn_output[:, :, : self.num_heads // 2],\n                attn_output[:, :, self.num_heads // 2 :].roll(groupsz // 2, dims=1),\n            ),\n            dim=2,\n        )\n\n    attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n    attn_output = self.o_proj(attn_output)\n\n    if not output_attentions:\n        attn_weights = None\n\n    return attn_output, attn_weights, past_key_value\n\n\n\n\ndef llama_sdpa_attention_forward(\n    self: \"LlamaSdpaAttention\",\n    hidden_states: torch.Tensor,\n    attention_mask: Optional[torch.Tensor] = None,\n    position_ids: Optional[torch.LongTensor] = None,\n    past_key_value: Optional[\"Cache\"] = None,\n    output_attentions: bool = False,\n    cache_position: Optional[torch.LongTensor] = None,\n    **kwargs,\n) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n    if output_attentions:\n        transformers_logger.warning_once(\n            \"SDPA does not support `output_attentions=True`. Falling back to the vanilla attention\"\n        )\n        return llama_attention_forward(\n            self,\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_value=past_key_value,\n            output_attentions=output_attentions,\n            cache_position=cache_position,\n            **kwargs,\n        )\n\n    bsz, q_len, _ = hidden_states.size()\n\n    query_states: \"torch.Tensor\" = self.q_proj(hidden_states)\n    key_states: \"torch.Tensor\" = self.k_proj(hidden_states)\n    value_states: \"torch.Tensor\" = self.v_proj(hidden_states)\n\n    query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n    key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n    value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n    cos, sin = self.rotary_emb(value_states, position_ids)\n    query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n    if past_key_value is not None:\n        cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n        key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n    key_states = repeat_kv(key_states, self.num_key_value_groups)\n    value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n    if getattr(self.config, \"group_size_ratio\", None) and self.training:  \n        groupsz = int(q_len * getattr(self.config, \"group_size_ratio\"))\n        assert q_len % groupsz == 0, \"q_len {} should be divisible by group size {}.\".format(q_len, groupsz)\n        num_groups = q_len // groupsz\n\n        def shift(state: \"torch.Tensor\") -> \"torch.Tensor\":\n            state = state.transpose(1, 2)  \n            state = torch.cat(\n                (state[:, :, : self.num_heads // 2], state[:, :, self.num_heads // 2 :].roll(-groupsz // 2, dims=1)),\n                dim=2,\n            )\n            return state.reshape(bsz * num_groups, groupsz, self.num_heads, self.head_dim).transpose(1, 2)\n\n        query_states, key_states, value_states = shift(query_states), shift(key_states), shift(value_states)\n        if attention_mask is not None:\n            attention_mask = attention_mask[:, :, :groupsz, :groupsz].repeat(num_groups, 1, 1, 1)\n\n    causal_mask = attention_mask\n    if attention_mask is not None:\n        causal_mask = causal_mask[:, :, :, : key_states.shape[-2]]\n\n    if query_states.device.type == \"cuda\" and causal_mask is not None:  \n        query_states = query_states.contiguous()\n        key_states = key_states.contiguous()\n        value_states = value_states.contiguous()\n\n    is_causal = True if causal_mask is None and q_len > 1 else False\n    attn_output = torch.nn.functional.scaled_dot_product_attention(\n        query_states,\n        key_states,\n        value_states,\n        attn_mask=causal_mask,\n        dropout_p=self.attention_dropout if self.training else 0.0,\n        is_causal=is_causal,\n    )\n    attn_output = attn_output.transpose(1, 2).contiguous()\n\n    if getattr(self.config, \"group_size_ratio\", None) and self.training:  \n        attn_output.reshape(bsz, q_len, self.num_heads, self.head_dim)\n        attn_output = torch.cat(\n            (\n                attn_output[:, :, : self.num_heads // 2],\n                attn_output[:, :, self.num_heads // 2 :].roll(groupsz // 2, dims=1),\n            ),\n            dim=2,\n        )\n\n    attn_output = attn_output.reshape(bsz, q_len, self.hidden_size)\n    attn_output = self.o_proj(attn_output)\n\n    return attn_output, None, past_key_value\n\n\ndef _apply_llama_patch() -> None:\n    require_version(\"transformers>=4.41.2,<=4.42.3\", \"To fix: pip install transformers>=4.41.2,<=4.42.3\")\n    LlamaAttention.forward = llama_attention_forward\n    LlamaFlashAttention2.forward = llama_flash_attention_2_forward\n    LlamaSdpaAttention.forward = llama_sdpa_attention_forward\n\n\ndef configure_longlora(config: \"PretrainedConfig\", model_args: \"ModelArguments\", is_trainable: bool) -> None:\n    if not is_trainable or not model_args.shift_attn:\n        return\n\n    logger = get_logger(__name__)\n\n    if getattr(config, \"model_type\", None) in SUPPORTED_CLASS_FOR_S2ATTN:\n        setattr(config, \"group_size_ratio\", 0.25)\n        _apply_llama_patch()\n        logger.info(\"Using shift short attention with group_size_ratio=1/4.\")\n    else:\n        logger.warning(\"Current model does not support shift short attention.\")\n```"
        }
    ],
    "temperature": 0
}