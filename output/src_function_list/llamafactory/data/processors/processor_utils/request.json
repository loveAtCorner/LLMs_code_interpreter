{
    "model": "qwen1.5-32b-chat-int4",
    "messages": [
        {
            "role": "system",
            "content": "你是python源码结构和逻辑的解析专家，非常擅长剖析核心代码的功能"
        },
        {
            "role": "user",
            "content": "返回下面这个脚本当中所有函数或者类的名称，及其对应的功能\n返回内容的格式需要遵循markdown表格的形式\n\n```python\nimport bisect\nfrom typing import TYPE_CHECKING, List, Sequence, Tuple\n\nfrom ...extras.packages import is_pillow_available\n\n\nif is_pillow_available():\n    from PIL import Image\n\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n    from PIL.Image import Image as ImageObject\n    from transformers import ProcessorMixin\n    from transformers.image_processing_utils import BaseImageProcessor\n\n\ndef search_for_fit(numbers: Sequence[int], capacity: int) -> int:\n    r\n    index = bisect.bisect(numbers, capacity)\n    return -1 if index == 0 else (index - 1)\n\n\ndef greedy_knapsack(numbers: List[int], capacity: int) -> List[List[int]]:\n    r\n    numbers.sort()  \n    knapsacks = []\n\n    while numbers:\n        current_knapsack = []\n        remaining_capacity = capacity\n\n        while True:\n            index = search_for_fit(numbers, remaining_capacity)\n            if index == -1:\n                break  \n\n            remaining_capacity -= numbers[index]  \n            current_knapsack.append(numbers.pop(index))  \n\n        knapsacks.append(current_knapsack)\n\n    return knapsacks\n\n\ndef get_pixel_values(images: Sequence[\"ImageObject\"], processor: \"ProcessorMixin\") -> \"NDArray\":\n    r\n    image_processor: \"BaseImageProcessor\" = getattr(processor, \"image_processor\")\n    image = images[0] if len(images) != 0 else Image.new(\"RGB\", (100, 100), (255, 255, 255))\n    return image_processor(image, return_tensors=\"pt\")[\"pixel_values\"][0]  \n\n\ndef get_paligemma_token_type_ids(input_len: int, processor: \"ProcessorMixin\") -> List[int]:\n    r\n    image_seq_length = getattr(processor, \"image_seq_length\")\n    return [0] * image_seq_length + [1] * (input_len - image_seq_length)\n\n\ndef infer_seqlen(source_len: int, target_len: int, cutoff_len: int) -> Tuple[int, int]:\n    r\n    if target_len * 2 < cutoff_len:  \n        max_target_len = cutoff_len\n    elif source_len * 2 < cutoff_len:  \n        max_target_len = cutoff_len - source_len\n    else:  \n        max_target_len = int(cutoff_len * (target_len / (source_len + target_len)))\n\n    new_target_len = min(max_target_len, target_len)\n    max_source_len = max(cutoff_len - new_target_len, 0)\n    new_source_len = min(max_source_len, source_len)\n    return new_source_len, new_target_len\n```"
        }
    ],
    "temperature": 0
}