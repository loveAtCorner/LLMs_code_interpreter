{
    "model": "qwen1.5-32b-chat-int4",
    "messages": [
        {
            "role": "system",
            "content": "你是python源码结构和逻辑的解析专家，非常擅长剖析核心代码的功能"
        },
        {
            "role": "user",
            "content": "返回下面这个脚本当中所有函数或者类的名称，及其对应的功能\n返回内容的格式需要遵循markdown表格的形式\n\n```python\nimport json\nimport re\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, List, Tuple, Union\n\nfrom .data_utils import SLOTS\n\n\nDEFAULT_TOOL_PROMPT = (\n    \"You have access to the following tools:\\n{tool_text}\"\n    \"Use the following format if using a tool:\\n\"\n    \"```\\n\"\n    \"Action: tool name (one of [{tool_names}]).\\n\"\n    \"Action Input: the input to the tool, in a JSON format representing the kwargs \"\n    \n    \"```\\n\"\n)\n\n\nGLM4_TOOL_PROMPT = (\n    \"你是一个名为 ChatGLM 的人工智能助手。你是基于智谱AI训练的语言模型 GLM-4 模型开发的，\"\n    \"你的任务是针对用户的问题和要求提供适当的答复和支持。\n)\n\n\n@dataclass\nclass ToolUtils(ABC):\n    @staticmethod\n    @abstractmethod\n    def get_function_slots() -> SLOTS: ...\n\n    @staticmethod\n    @abstractmethod\n    def tool_formatter(tools: List[Dict[str, Any]]) -> str: ...\n\n    @staticmethod\n    @abstractmethod\n    def tool_extractor(content: str) -> Union[str, List[Tuple[str, str]]]: ...\n\n\nclass DefaultToolUtils(ToolUtils):\n    @staticmethod\n    def get_function_slots() -> SLOTS:\n        return [\"Action: {{name}}\\nAction Input: {{arguments}}\\n\"]\n\n    @staticmethod\n    def tool_formatter(tools: List[Dict[str, Any]]) -> str:\n        tool_text = \"\"\n        tool_names = []\n        for tool in tools:\n            param_text = \"\"\n            for name, param in tool[\"parameters\"][\"properties\"].items():\n                required, enum, items = \"\", \"\", \"\"\n                if name in tool[\"parameters\"].get(\"required\", []):\n                    required = \", required\"\n\n                if param.get(\"enum\", None):\n                    enum = \", should be one of [{}]\".format(\", \".join(param[\"enum\"]))\n\n                if param.get(\"items\", None):\n                    items = \", where each item should be {}\".format(param[\"items\"].get(\"type\", \"\"))\n\n                param_text += \"  - {name} ({type}{required}): {desc}{enum}{items}\\n\".format(\n                    name=name,\n                    type=param.get(\"type\", \"\"),\n                    required=required,\n                    desc=param.get(\"description\", \"\"),\n                    enum=enum,\n                    items=items,\n                )\n\n            tool_text += \"> Tool Name: {name}\\nTool Description: {desc}\\nTool Args:\\n{args}\\n\".format(\n                name=tool[\"name\"], desc=tool.get(\"description\", \"\"), args=param_text\n            )\n            tool_names.append(tool[\"name\"])\n\n        return DEFAULT_TOOL_PROMPT.format(tool_text=tool_text, tool_names=\", \".join(tool_names))\n\n    @staticmethod\n    def tool_extractor(content: str) -> Union[str, List[Tuple[str, str]]]:\n        regex = re.compile(r\"Action:\\s*([a-zA-Z0-9_]+)\\s*Action Input:\\s*(.+?)(?=\\s*Action:|\\s*$)\", re.DOTALL)\n        action_match: List[Tuple[str, str]] = re.findall(regex, content)\n        if not action_match:\n            return content\n\n        results = []\n        for match in action_match:\n            tool_name = match[0].strip()\n            tool_input = match[1].strip().strip('\"').strip(\"```\")\n            try:\n                arguments = json.loads(tool_input)\n                results.append((tool_name, json.dumps(arguments, ensure_ascii=False)))\n            except json.JSONDecodeError:\n                return content\n\n        return results\n\n\nclass GLM4ToolUtils(ToolUtils):\n    @staticmethod\n    def get_function_slots() -> SLOTS:\n        return [\"{{name}}\\n{{arguments}}\"]\n\n    @staticmethod\n    def tool_formatter(tools: List[Dict[str, Any]]) -> str:\n        tool_text = \"\"\n        for tool in tools:\n            tool_text += \"\\n\\n\n                name=tool[\"name\"], body=json.dumps(tool, indent=4, ensure_ascii=False)\n            )\n\n        return GLM4_TOOL_PROMPT.format(tool_text=tool_text)\n\n    @staticmethod\n    def tool_extractor(content: str) -> Union[str, List[Tuple[str, str]]]:\n        if \"\\n\" not in content:\n            return content\n\n        tool_name, tool_input = content.split(\"\\n\", maxsplit=1)\n        try:\n            arguments = json.loads(tool_input)\n        except json.JSONDecodeError:\n            return content\n\n        return [(tool_name, json.dumps(arguments, ensure_ascii=False))]\n```"
        }
    ],
    "temperature": 0
}