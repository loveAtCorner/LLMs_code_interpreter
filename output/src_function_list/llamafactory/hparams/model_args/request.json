{
    "model": "qwen1.5-32b-chat-int4",
    "messages": [
        {
            "role": "system",
            "content": "你是python源码结构和逻辑的解析专家，非常擅长剖析核心代码的功能"
        },
        {
            "role": "user",
            "content": "返回下面这个脚本当中所有函数或者类的名称，及其对应的功能\n返回内容的格式需要遵循markdown表格的形式\n\n```python\nfrom dataclasses import asdict, dataclass, field\nfrom typing import TYPE_CHECKING, Any, Dict, Literal, Optional, Union\n\nfrom typing_extensions import Self\n\n\nif TYPE_CHECKING:\n    import torch\n\n\n@dataclass\nclass ModelArguments:\n    r\n\n    model_name_or_path: str = field(\n        metadata={\n            \"help\": \"Path to the model weight or identifier from huggingface.co/models or modelscope.cn/models.\"\n        },\n    )\n    adapter_name_or_path: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"Path to the adapter weight or identifier from huggingface.co/models. \"\n                \"Use commas to separate multiple adapters.\"\n            )\n        },\n    )\n    adapter_folder: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The folder containing the adapter weights to load.\"},\n    )\n    cache_dir: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Where to store the pre-trained models downloaded from huggingface.co or modelscope.cn.\"},\n    )\n    use_fast_tokenizer: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether or not to use one of the fast tokenizer (backed by the tokenizers library).\"},\n    )\n    resize_vocab: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to resize the tokenizer vocab and the embedding layers.\"},\n    )\n    split_special_tokens: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not the special tokens should be split during the tokenization process.\"},\n    )\n    new_special_tokens: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Special tokens to be added into the tokenizer. Use commas to separate multiple tokens.\"},\n    )\n    model_revision: str = field(\n        default=\"main\",\n        metadata={\"help\": \"The specific model version to use (can be a branch name, tag name or commit id).\"},\n    )\n    low_cpu_mem_usage: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether or not to use memory-efficient model loading.\"},\n    )\n    quantization_method: Literal[\"bitsandbytes\", \"hqq\", \"eetq\"] = field(\n        default=\"bitsandbytes\",\n        metadata={\"help\": \"Quantization method to use for on-the-fly quantization.\"},\n    )\n    quantization_bit: Optional[int] = field(\n        default=None,\n        metadata={\"help\": \"The number of bits to quantize the model using bitsandbytes.\"},\n    )\n    quantization_type: Literal[\"fp4\", \"nf4\"] = field(\n        default=\"nf4\",\n        metadata={\"help\": \"Quantization data type to use in int4 training.\"},\n    )\n    double_quantization: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether or not to use double quantization in int4 training.\"},\n    )\n    quantization_device_map: Optional[Literal[\"auto\"]] = field(\n        default=None,\n        metadata={\"help\": \"Device map used to infer the 4-bit quantized model, needs bitsandbytes>=0.43.0.\"},\n    )\n    rope_scaling: Optional[Literal[\"linear\", \"dynamic\"]] = field(\n        default=None,\n        metadata={\"help\": \"Which scaling strategy should be adopted for the RoPE embeddings.\"},\n    )\n    flash_attn: Literal[\"auto\", \"disabled\", \"sdpa\", \"fa2\"] = field(\n        default=\"auto\",\n        metadata={\"help\": \"Enable FlashAttention for faster training and inference.\"},\n    )\n    shift_attn: bool = field(\n        default=False,\n        metadata={\"help\": \"Enable shift short attention (S^2-Attn) proposed by LongLoRA.\"},\n    )\n    mixture_of_depths: Optional[Literal[\"convert\", \"load\"]] = field(\n        default=None,\n        metadata={\"help\": \"Convert the model to mixture-of-depths (MoD) or load the MoD model.\"},\n    )\n    use_unsloth: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to use unsloth's optimization for the LoRA training.\"},\n    )\n    visual_inputs: bool = field(\n        default=False,\n        metadata={\"help\": \"Whethor or not to use multimodal LLM that accepts visual inputs.\"},\n    )\n    moe_aux_loss_coef: Optional[float] = field(\n        default=None,\n        metadata={\"help\": \"Coefficient of the auxiliary router loss in mixture-of-experts model.\"},\n    )\n    disable_gradient_checkpointing: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to disable gradient checkpointing.\"},\n    )\n    upcast_layernorm: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to upcast the layernorm weights in fp32.\"},\n    )\n    upcast_lmhead_output: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to upcast the output of lm_head in fp32.\"},\n    )\n    train_from_scratch: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to randomly initialize the model weights.\"},\n    )\n    infer_backend: Literal[\"huggingface\", \"vllm\"] = field(\n        default=\"huggingface\",\n        metadata={\"help\": \"Backend engine used at inference.\"},\n    )\n    vllm_maxlen: int = field(\n        default=2048,\n        metadata={\"help\": \"Maximum sequence (prompt + response) length of the vLLM engine.\"},\n    )\n    vllm_gpu_util: float = field(\n        default=0.9,\n        metadata={\"help\": \"The fraction of GPU memory in (0,1) to be used for the vLLM engine.\"},\n    )\n    vllm_enforce_eager: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to disable CUDA graph in the vLLM engine.\"},\n    )\n    vllm_max_lora_rank: int = field(\n        default=32,\n        metadata={\"help\": \"Maximum rank of all LoRAs in the vLLM engine.\"},\n    )\n    offload_folder: str = field(\n        default=\"offload\",\n        metadata={\"help\": \"Path to offload model weights.\"},\n    )\n    use_cache: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether or not to use KV cache in generation.\"},\n    )\n    infer_dtype: Literal[\"auto\", \"float16\", \"bfloat16\", \"float32\"] = field(\n        default=\"auto\",\n        metadata={\"help\": \"Data type for model weights and activations at inference.\"},\n    )\n    hf_hub_token: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Auth token to log in with Hugging Face Hub.\"},\n    )\n    ms_hub_token: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Auth token to log in with ModelScope Hub.\"},\n    )\n    export_dir: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Path to the directory to save the exported model.\"},\n    )\n    export_size: int = field(\n        default=1,\n        metadata={\"help\": \"The file shard size (in GB) of the exported model.\"},\n    )\n    export_device: Literal[\"cpu\", \"auto\"] = field(\n        default=\"cpu\",\n        metadata={\"help\": \"The device used in model export, use `auto` to accelerate exporting.\"},\n    )\n    export_quantization_bit: Optional[int] = field(\n        default=None,\n        metadata={\"help\": \"The number of bits to quantize the exported model.\"},\n    )\n    export_quantization_dataset: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Path to the dataset or dataset name to use in quantizing the exported model.\"},\n    )\n    export_quantization_nsamples: int = field(\n        default=128,\n        metadata={\"help\": \"The number of samples used for quantization.\"},\n    )\n    export_quantization_maxlen: int = field(\n        default=1024,\n        metadata={\"help\": \"The maximum length of the model inputs used for quantization.\"},\n    )\n    export_legacy_format: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether or not to save the `.bin` files instead of `.safetensors`.\"},\n    )\n    export_hub_model_id: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the repository if push the model to the Hugging Face hub.\"},\n    )\n    print_param_status: bool = field(\n        default=False,\n        metadata={\"help\": \"For debugging purposes, print the status of the parameters in the model.\"},\n    )\n\n    def __post_init__(self):\n        self.compute_dtype: Optional[\"torch.dtype\"] = None\n        self.device_map: Optional[Union[str, Dict[str, Any]]] = None\n        self.model_max_length: Optional[int] = None\n        self.block_diag_attn: bool = False\n\n        if self.split_special_tokens and self.use_fast_tokenizer:\n            raise ValueError(\"`split_special_tokens` is only supported for slow tokenizers.\")\n\n        if self.visual_inputs and self.use_unsloth:\n            raise ValueError(\"Unsloth does not support MLLM yet. Stay tuned.\")\n\n        if self.adapter_name_or_path is not None:  \n            self.adapter_name_or_path = [path.strip() for path in self.adapter_name_or_path.split(\",\")]\n\n        if self.new_special_tokens is not None:  \n            self.new_special_tokens = [token.strip() for token in self.new_special_tokens.split(\",\")]\n\n        if self.export_quantization_bit is not None and self.export_quantization_dataset is None:\n            raise ValueError(\"Quantization dataset is necessary for exporting.\")\n\n    def to_dict(self) -> Dict[str, Any]:\n        return asdict(self)\n\n    @classmethod\n    def copyfrom(cls, old_arg: Self, **kwargs) -> Self:\n        arg_dict = old_arg.to_dict()\n        arg_dict.update(**kwargs)\n        new_arg = cls(**arg_dict)\n        new_arg.compute_dtype = old_arg.compute_dtype\n        new_arg.device_map = old_arg.device_map\n        new_arg.model_max_length = old_arg.model_max_length\n        new_arg.block_diag_attn = old_arg.block_diag_attn\n        return new_arg\n```"
        }
    ],
    "temperature": 0
}