{
    "model": "qwen1.5-32b-chat-int4",
    "messages": [
        {
            "role": "system",
            "content": "你是python源码结构和逻辑的解析专家，非常擅长剖析核心代码的功能"
        },
        {
            "role": "user",
            "content": "返回下面这个脚本当中所有函数或者类的名称，及其对应的功能\n返回内容的格式需要遵循markdown表格的形式\n\n```python\nfrom typing import TYPE_CHECKING, List, Optional\n\nfrom ...data import SFTDataCollatorWith4DAttentionMask, get_dataset, split_dataset\nfrom ...extras.constants import IGNORE_INDEX\nfrom ...extras.misc import get_logits_processor\nfrom ...extras.ploting import plot_loss\nfrom ...model import load_model, load_tokenizer\nfrom ..trainer_utils import create_modelcard_and_push\nfrom .metric import ComputeMetrics, compute_accuracy, eval_logit_processor\nfrom .trainer import CustomSeq2SeqTrainer\n\n\nif TYPE_CHECKING:\n    from transformers import Seq2SeqTrainingArguments, TrainerCallback\n\n    from ...hparams import DataArguments, FinetuningArguments, GeneratingArguments, ModelArguments\n\n\ndef run_sft(\n    model_args: \"ModelArguments\",\n    data_args: \"DataArguments\",\n    training_args: \"Seq2SeqTrainingArguments\",\n    finetuning_args: \"FinetuningArguments\",\n    generating_args: \"GeneratingArguments\",\n    callbacks: Optional[List[\"TrainerCallback\"]] = None,\n):\n    tokenizer_module = load_tokenizer(model_args)\n    tokenizer = tokenizer_module[\"tokenizer\"]\n    dataset = get_dataset(model_args, data_args, training_args, stage=\"sft\", **tokenizer_module)\n    model = load_model(tokenizer, model_args, finetuning_args, training_args.do_train)\n\n    if training_args.predict_with_generate:\n        tokenizer.padding_side = \"left\"  \n\n    if getattr(model, \"is_quantized\", False) and not training_args.do_train:\n        setattr(model, \"_hf_peft_config_loaded\", True)  \n\n    data_collator = SFTDataCollatorWith4DAttentionMask(\n        tokenizer=tokenizer,\n        pad_to_multiple_of=8 if tokenizer.padding_side == \"right\" else None,  \n        label_pad_token_id=IGNORE_INDEX if data_args.ignore_pad_token_for_loss else tokenizer.pad_token_id,\n        block_diag_attn=model_args.block_diag_attn,\n        attn_implementation=getattr(model.config, \"_attn_implementation\", None),\n        compute_dtype=model_args.compute_dtype,\n    )\n\n    \n    training_args.generation_max_length = training_args.generation_max_length or data_args.cutoff_len\n    training_args.generation_num_beams = data_args.eval_num_beams or training_args.generation_num_beams\n    training_args.remove_unused_columns = False if model_args.visual_inputs else training_args.remove_unused_columns\n\n    \n    trainer = CustomSeq2SeqTrainer(\n        model=model,\n        args=training_args,\n        finetuning_args=finetuning_args,\n        data_collator=data_collator,\n        callbacks=callbacks,\n        compute_metrics=ComputeMetrics(tokenizer) if training_args.predict_with_generate else compute_accuracy,\n        preprocess_logits_for_metrics=None if training_args.predict_with_generate else eval_logit_processor,\n        **tokenizer_module,\n        **split_dataset(dataset, data_args, training_args),\n    )\n\n    \n    gen_kwargs = generating_args.to_dict()\n    gen_kwargs[\"eos_token_id\"] = [tokenizer.eos_token_id] + tokenizer.additional_special_tokens_ids\n    gen_kwargs[\"pad_token_id\"] = tokenizer.pad_token_id\n    gen_kwargs[\"logits_processor\"] = get_logits_processor()\n\n    \n    if training_args.do_train:\n        train_result = trainer.train(resume_from_checkpoint=training_args.resume_from_checkpoint)\n        trainer.save_model()\n        trainer.log_metrics(\"train\", train_result.metrics)\n        trainer.save_metrics(\"train\", train_result.metrics)\n        trainer.save_state()\n        if trainer.is_world_process_zero() and finetuning_args.plot_loss:\n            plot_loss(training_args.output_dir, keys=[\"loss\", \"eval_loss\", \"eval_accuracy\"])\n\n    \n    if training_args.do_eval:\n        metrics = trainer.evaluate(metric_key_prefix=\"eval\", **gen_kwargs)\n        if training_args.predict_with_generate:  \n            metrics.pop(\"eval_loss\", None)\n        trainer.log_metrics(\"eval\", metrics)\n        trainer.save_metrics(\"eval\", metrics)\n\n    \n    if training_args.do_predict:\n        predict_results = trainer.predict(dataset, metric_key_prefix=\"predict\", **gen_kwargs)\n        if training_args.predict_with_generate:  \n            predict_results.metrics.pop(\"predict_loss\", None)\n        trainer.log_metrics(\"predict\", predict_results.metrics)\n        trainer.save_metrics(\"predict\", predict_results.metrics)\n        trainer.save_predictions(dataset, predict_results)\n\n    \n    create_modelcard_and_push(trainer, model_args, data_args, training_args, finetuning_args)\n```"
        }
    ],
    "temperature": 0
}